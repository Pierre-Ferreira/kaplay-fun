import { Polygon, Vec2 } from "../../math";
import type { Comp, GameObj } from "../../types";
import type { BodyComp } from "./body";
export type SurfaceEffectorCompOpt = {
    speed: number;
    speedVariation?: number;
    forceScale?: number;
};
export interface SurfaceEffectorComp extends Comp {
    speed: number;
    speedVariation: number;
    forceScale: number;
}
export declare function surfaceEffector(opts: SurfaceEffectorCompOpt): SurfaceEffectorComp;
export type AreaEffectorCompOpt = {
    useGlobalAngle?: boolean;
    forceAngle: number;
    forceMagnitude: number;
    forceVariation?: number;
    linearDrag?: number;
};
export interface AreaEffectorComp extends Comp {
    useGlobalAngle: boolean;
    forceAngle: number;
    forceMagnitude: number;
    forceVariation: number;
    linearDrag?: number;
}
export declare function areaEffector(opts: AreaEffectorCompOpt): AreaEffectorComp;
export type ForceMode = "constant" | "inverseLinear" | "inverseSquared";
export type PointEffectorCompOpt = {
    forceMagnitude: number;
    forceVariation: number;
    distanceScale?: number;
    forceMode?: ForceMode;
    linearDrag?: number;
};
export interface PointEffectorComp extends Comp {
    forceMagnitude: number;
    forceVariation: number;
    distanceScale: number;
    forceMode: ForceMode;
    linearDrag: number;
}
export declare function pointEffector(opts: PointEffectorCompOpt): PointEffectorComp;
export type ConstantForceCompOpt = {
    force?: Vec2;
};
export interface ConstantForceComp extends Comp {
    force?: Vec2;
}
export declare function constantForce(opts: ConstantForceCompOpt): ConstantForceComp;
export type PlatformEffectorCompOpt = {
    /**
     * If the object is about to collide and the collision normal direction is
     * in here, the object won't collide.
     *
     * Should be a list of unit vectors `LEFT`, `RIGHT`, `UP`, or `DOWN`.
     */
    ignoreSides?: Vec2[];
    /**
     * A function that determines whether the object should collide.
     *
     * If present, it overrides the `ignoreSides`; if absent, it is
     * automatically created from `ignoreSides`.
     */
    shouldCollide?: (obj: GameObj, normal: Vec2) => boolean;
};
export interface PlatformEffectorComp extends Comp {
    /**
     * A set of the objects that should not collide with this, because `shouldCollide` returned true.
     *
     * Objects in here are automatically removed when they stop colliding, so the casual user shouldn't
     * need to touch this much. However, if an object is added to this set before the object collides
     * with the platform effector, it won't collide even if `shouldCollide` returns true.
     */
    platformIgnore: Set<GameObj>;
}
export declare function platformEffector(opt?: PlatformEffectorCompOpt): PlatformEffectorComp;
export type BuoyancyEffectorCompOpt = {
    surfaceLevel: number;
    density?: number;
    linearDrag?: number;
    angularDrag?: number;
    flowAngle?: number;
    flowMagnitude?: number;
    flowVariation?: number;
};
export interface BuoyancyEffectorComp extends Comp {
    surfaceLevel: number;
    density: number;
    linearDrag: number;
    angularDrag: number;
    flowAngle: number;
    flowMagnitude: number;
    flowVariation: number;
    applyBuoyancy(body: GameObj<BodyComp>, submergedArea: Polygon): void;
    applyDrag(body: GameObj<BodyComp>, submergedArea: Polygon): void;
}
export declare function buoyancyEffector(opts: BuoyancyEffectorCompOpt): BuoyancyEffectorComp;
//# sourceMappingURL=effectors.d.ts.map